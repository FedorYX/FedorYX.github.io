<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fedor 的小花园与大世界</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fedoryx.github.io/"/>
  <updated>2019-05-19T13:14:42.000Z</updated>
  <id>https://fedoryx.github.io/</id>
  
  <author>
    <name>Fedor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tornado ZMQ CPU密集型应用异步方案</title>
    <link href="https://fedoryx.github.io/Tornado-ZMQ-CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E5%BC%82%E6%AD%A5%E6%96%B9%E6%A1%88/"/>
    <id>https://fedoryx.github.io/Tornado-ZMQ-CPU密集型应用异步方案/</id>
    <published>2019-05-19T02:46:53.000Z</published>
    <updated>2019-05-19T13:14:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Tornado是一款Python 服务器框架，其采用异步IO 的网络模型，具有较高性能。在Tornado 基础上为了提升Cpu 密集型应用在多核Cpu 服务器上的性能表现，可以采用Tornado 协程（异步非阻塞）+队列（通信、解耦）+多线程/多进程任务（榨干多核Cpu）的方案。</p><a id="more"></a><h2 id="一-简易Tornado服务"><a href="#一-简易Tornado服务" class="headerlink" title="一. 简易Tornado服务"></a>一. 简易Tornado服务</h2><p><a href="https://www.tornadoweb.org/en/stable/" target="_blank" rel="noopener">Tornado</a> 的详细内容参考官网，这里结合实际应用介绍Tornado 的核心知识点。</p><p>Tornado 作为http 服务器，其核心模块由上至下为 HTTPServer - Application - RequestHandler 三级。简单搭建一个http 服务demo，demo 中包含一个耗时任务，用来模拟Cpu 密集型任务。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import random</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">import tornado</span><br><span class="line">from tornado import ioloop</span><br><span class="line">from tornado import web</span><br><span class="line">import tornado.httpserver</span><br><span class="line"></span><br><span class="line">def dot():</span><br><span class="line">    &quot;&quot;&quot;callback for showing that IOLoop is still responsive while we wait&quot;&quot;&quot;</span><br><span class="line">    sys.stdout.write(&apos;.&apos;)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line">def slow_responder(num):</span><br><span class="line">    print(num)</span><br><span class="line">    time.sleep(random.randint(1,5))</span><br><span class="line">    </span><br><span class="line">class TestHandler(web.RequestHandler):</span><br><span class="line">    </span><br><span class="line">    def get(self):</span><br><span class="line">        print(&quot;get request&quot;)</span><br><span class="line">        slow_responder(5)</span><br><span class="line">        res =  &quot;get http request&quot;</span><br><span class="line">        print(res)</span><br><span class="line">        self.write(res)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    application = web.Application([(r&quot;/&quot;, TestHandler)])</span><br><span class="line">    server = tornado.httpserver.HTTPServer(application)</span><br><span class="line">    server.bind(8886)</span><br><span class="line">    #specify number of subprocess</span><br><span class="line">    server.start(1)</span><br><span class="line">    </span><br><span class="line">    beat = ioloop.PeriodicCallback(dot, 100)</span><br><span class="line">    beat.start()</span><br><span class="line">    </span><br><span class="line">    try:</span><br><span class="line">        ioloop.IOLoop.instance().start()</span><br><span class="line">    except KeyboardInterrupt:</span><br><span class="line">        print(&apos; Interrupted&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行程序并在浏览器进行请求，服务器会收到字符信息“get http request”，同时控制台显示结果如下。点点点为心跳信号，证明服务器在运行状态。观察到在接收到请求后等待几秒后才返回请求，同时这段时间内心跳信号消失，说明此时程序在处理耗时任务，不能响应其他请求连接。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...................................get request</span><br><span class="line">5</span><br><span class="line">get http request</span><br><span class="line">...............................................................................</span><br></pre></td></tr></table></figure><p>问题来了，不是说Tronado 是高性能的网络连接库吗，这里为什么不能响应其他连接呢？</p><ol><li>Tronado 采用 epoll 技术实现高并发网络连接，与通常采用多线程或多进程并发连接的技术方案不同，Tornado 默认是单进程单线程的。即demo 中 server、application 及handler 处在同一个进程及同一个主线程中。对于高并发技术方案可参考<a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">《C10K问题》</a>。</li><li>大家对网络连接的概念没有搞清楚，默认网络连接和请求响应任务处理是同一件事。高并发仅针对网络连接而言，与任务处理无关。当10台远端服务器同时请求我的http服务时，10个连接其实都已建立，但由于任务耗时较长，第一个连接的任务尚未处理完毕，其他9个连接的任务只能等待，造成程序阻塞。</li><li>高并发（连接）与高性能其实并不等同，对于IO 密集型服务由于任务Cpu 耗时短，高并发与高性能可近似相等，但Cpu 密集型任务则不能单单考虑高并发，还需考虑具体任务的性能。</li></ol><h2 id="二-多进程、多线程及协程"><a href="#二-多进程、多线程及协程" class="headerlink" title="二.多进程、多线程及协程"></a>二.多进程、多线程及协程</h2><p>提升服务性能通常可以通过增强程序的并行处理能力来得到提高，常用的并行方案包括多进程、多线程及协程。多进程和多线程是操作系统提供及控制的，协程是应用程序自己控制的。下面对当前情景下的几种并行方案进行分析。</p><h3 id="1-多进程"><a href="#1-多进程" class="headerlink" title="1.多进程"></a>1.多进程</h3><p>Tornado 多进程可通过构建多个Application实例实现，仅需对代码进行简单修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#开启2个进程</span><br><span class="line">server.start(2)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">............get request</span><br><span class="line">5</span><br><span class="line">..............................get request</span><br><span class="line">5</span><br><span class="line">.........................................get http request</span><br><span class="line">.............................get http request</span><br><span class="line">....................................................</span><br></pre></td></tr></table></figure><p>可以看出服务器处理了两个请求连接后进行输出，实现了并行。</p><p>Tornado 多进程的方式简单粗暴，但这种方案也有其缺点：</p><p>*a.系统的进程资源很宝贵，最大进程数有限。</p><p>*b.进程成本很高，多进程程序等于同一份程序复制n遍，耗费资源（内存、Cpu 上下文切换）较大。</p><h3 id="2-多线程"><a href="#2-多线程" class="headerlink" title="2.多线程"></a>2.多线程</h3><p>多线程相比多进程占用系统资源少，但线程之间需要考虑同步及死锁等问题，同时大量线程cpu调度也是需要考虑的问题。</p><p>对于当前应用场景，最大的问题其实是Python GIL（Global Interpreter Lock），这是一把全局解释器锁，再多的线程在解释器层面其实只相当于一个线程，所以Python 中通常不采用多线程的方案。</p><h3 id="3-协程"><a href="#3-协程" class="headerlink" title="3.协程"></a>3.协程</h3><p>协程简单理解可以认为是用户态微线程。即用户自己控制（非操作系统调度）的微线程，并且多个微线程可以在单一线程下运行，没有线程切换的开销，执行效率极高。</p><p>综上，采用协程对于实现请求异步非阻塞处理是最佳方案。下面是采用协程的代码修改部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from tornado import gen  </span><br><span class="line"></span><br><span class="line">class TestHandler(web.RequestHandler):</span><br><span class="line">    </span><br><span class="line">    @gen.coroutine</span><br><span class="line">    def get(self):</span><br><span class="line">        print(&quot;get request&quot;)</span><br><span class="line">        slow_responder(5)</span><br><span class="line">        res =  &quot;get http request&quot;</span><br><span class="line">        print(res)</span><br><span class="line">        self.write(res)</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.............get request</span><br><span class="line">5</span><br><span class="line">..................get request</span><br><span class="line">5</span><br><span class="line">........................................get http request</span><br><span class="line">.........................................................................get http request</span><br></pre></td></tr></table></figure><p>可以看出，协程方案实现了并行效果。现在是不是可以大功告成了呢，其实差矣，因为之前说过，Tornado 默认单进程单线程，即使请求处理改造成并行，但任务处理仍是单线程执行，整体程序性能仍较低。因此需要进一步改造。</p><h2 id="三-多线程-多进程任务-任务队列分发"><a href="#三-多线程-多进程任务-任务队列分发" class="headerlink" title="三.多线程/多进程任务+任务队列分发"></a>三.多线程/多进程任务+任务队列分发</h2><p>现代服务器Cpu 核数可是很多的（至少8核），单进程单线程跑在一个Cpu 上岂不是浪费资源。因此最容易想到的就是将任务通过多线程最大化利用多核Cpu。多线程后面临的一个问题就是线程间消息的通信，如何将任务分发到线程及获取线程处理结果。这时就需要消息队列来进行通信和解耦。这里使用<a href="http://zeromq.org/" target="_blank" rel="noopener">zeroMQ</a> 作为消息队列。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import random</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">import zmq</span><br><span class="line">from zmq.eventloop.future import Context as FutureContext</span><br><span class="line">from zmq.devices.basedevice import ProcessDevice</span><br><span class="line"></span><br><span class="line">import tornado</span><br><span class="line">from tornado import gen</span><br><span class="line">from tornado import ioloop</span><br><span class="line">from tornado import web</span><br><span class="line">import tornado.httpserver</span><br><span class="line"></span><br><span class="line">def fast_worker(num):</span><br><span class="line">    &quot;&quot;&quot;thread for slowly responding to replies.&quot;&quot;&quot;</span><br><span class="line">    ctx = zmq.Context()</span><br><span class="line">    socket = ctx.socket(zmq.DEALER)</span><br><span class="line">    socket.connect(&apos;tcp://127.0.0.1:5556&apos;)</span><br><span class="line">    i = 0</span><br><span class="line">    while True:</span><br><span class="line">        frame, msg = socket.recv_multipart()</span><br><span class="line">        print(&quot;\nworker received %r\n&quot; % msg, end=&apos;&apos;)</span><br><span class="line">        print(num)</span><br><span class="line">        time.sleep(random.randint(1,5))</span><br><span class="line">        socket.send_multipart([frame, msg + b&quot; to you too, #%i&quot; % i])</span><br><span class="line">        i += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dot():</span><br><span class="line">    &quot;&quot;&quot;callback for showing that IOLoop is still responsive while we wait&quot;&quot;&quot;</span><br><span class="line">    sys.stdout.write(&apos;.&apos;)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line">class TestHandler(web.RequestHandler):</span><br><span class="line">    </span><br><span class="line">    @gen.coroutine</span><br><span class="line">    def get(self):</span><br><span class="line">        ctx = FutureContext.instance()</span><br><span class="line">        s = ctx.socket(zmq.DEALER)</span><br><span class="line"></span><br><span class="line">        s.connect(&apos;tcp://127.0.0.1:5555&apos;)</span><br><span class="line">        # send request to worker</span><br><span class="line">        yield s.send(b&apos;hello&apos;)</span><br><span class="line">        # finish web request with worker&apos;s reply</span><br><span class="line">        reply = yield s.recv()</span><br><span class="line">        print(&quot;\nfinishing with %r\n&quot; % reply)</span><br><span class="line">        s.close()</span><br><span class="line">        self.write(reply)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line"></span><br><span class="line">    worker2 = threading.Thread(target=fast_worker,args=(2,))</span><br><span class="line">    worker2.daemon=True</span><br><span class="line">    worker2.start()</span><br><span class="line"></span><br><span class="line">    worker1 = threading.Thread(target=fast_worker,args=(1,))</span><br><span class="line">    worker1.daemon=True</span><br><span class="line">    worker1.start()</span><br><span class="line"></span><br><span class="line">    queuedevice = ProcessDevice(zmq.QUEUE, zmq.ROUTER, zmq.DEALER)</span><br><span class="line">    queuedevice.bind_in(&apos;tcp://127.0.0.1:5555&apos;)</span><br><span class="line">    queuedevice.bind_out(&apos;tcp://127.0.0.1:5556&apos;)</span><br><span class="line">    queuedevice.start()</span><br><span class="line"></span><br><span class="line">    application = web.Application([(r&quot;/&quot;, TestHandler)])</span><br><span class="line">    server = tornado.httpserver.HTTPServer(application)</span><br><span class="line">    server.bind(8886)</span><br><span class="line">    #specify number of subprocess</span><br><span class="line">    server.start(1)</span><br><span class="line">    beat = ioloop.PeriodicCallback(dot, 100)</span><br><span class="line">    beat.start()</span><br><span class="line">    try:</span><br><span class="line">        ioloop.IOLoop.instance().start()</span><br><span class="line">    except KeyboardInterrupt:</span><br><span class="line">        print(&apos; Interrupted&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.........................</span><br><span class="line">worker received b&apos;hello&apos;</span><br><span class="line">1</span><br><span class="line">...</span><br><span class="line">worker received b&apos;hello&apos;</span><br><span class="line">2</span><br><span class="line">...............................</span><br><span class="line">finishing with b&apos;hello to you too, #0&apos;</span><br><span class="line"></span><br><span class="line">...............</span><br><span class="line">finishing with b&apos;hello to you too, #0&apos;</span><br></pre></td></tr></table></figure><p>通过多线程+消息队列我们实现了任务并行，可充分榨干多核Cpu 性能，提升Cpu 密集型服务的处理能力。</p><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h2><p>这种方案性能的提升留给大家自己去实践和测试。对于Cpu 密集型应用，如何最大化提升性能仍任重而道远。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tornado是一款Python 服务器框架，其采用异步IO 的网络模型，具有较高性能。在Tornado 基础上为了提升Cpu 密集型应用在多核Cpu 服务器上的性能表现，可以采用Tornado 协程（异步非阻塞）+队列（通信、解耦）+多线程/多进程任务（榨干多核Cpu）的方案。&lt;/p&gt;
    
    </summary>
    
      <category term="服务" scheme="https://fedoryx.github.io/categories/%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="工程" scheme="https://fedoryx.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>LNMP Docker环境搭建 -- PHP 开发系列(1)</title>
    <link href="https://fedoryx.github.io/LNMP-Docker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-PHP-%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97-1/"/>
    <id>https://fedoryx.github.io/LNMP-Docker环境搭建-PHP-开发系列-1/</id>
    <published>2017-08-28T17:02:55.000Z</published>
    <updated>2017-08-31T14:57:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>互联网是一门实践科学，想要学习 PHP 第一要务即搭建 PHP 开发环境，有了开发环境则可边学习边实践，效果比只看视频和教程好很多。博主也是个 PHP 初学者，搭建环境也并不是一番风顺。本文记录了通过 Docker 搭建 LNMP  Web 开发环境过程，以帮助初学者快速搭建一个简单易上手的开发环境。</p><a id="more"></a><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h1><p>LNMP 是指一组通常一起使用来运行动态网站或者服务器的自由软件名称首字母缩写：</p><ul><li>Linux</li><li>Nginx</li><li>MySQL</li><li>PHP</li></ul><p>搭建环境前需要安装 Docker 相关软件：</p><ol><li>Docker for MAC</li><li>Kitematic</li></ol><p>若不了解 Docker 相关知识，可参考博主前文<a href="https://fedoryx.github.io/%E5%88%A9%E7%94%A8-GitHub-Hexo-Docker-%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2-MAC%E7%AF%87/">《利用 GitHub + Hexo + Docker 快速构建独立博客 – MAC篇》</a>。</p><h1 id="LNMP-Docker-环境搭建"><a href="#LNMP-Docker-环境搭建" class="headerlink" title="LNMP Docker 环境搭建"></a>LNMP Docker 环境搭建</h1><p>LNMP Docke 配置采用 Github 上的开源项目 <a href="https://github.com/micooz/docker-lnmp" target="_blank" rel="noopener">micooz/docker-lnmp</a>。</p><p>LNMP Docker 环境整体结构如下图所示：</p><p><img src="https://github.com/micooz/docker-lnmp/raw/master/architecture.png" alt="image"></p><p>Docker 环境中共有3个 Container，分别安装 Nginx、PHP-FPM、MySQL，通过 docker-compose.yml 文件配置3个 Container 间的连接关系。同时 docker-compose.yml 也配置了 Contain 中映射到宿主机的相关文件路径，即图中所示 Mount 部分。</p><p>下面介绍具体的环境搭建过程：</p><p>1.download 或 clone github 工程至本地。 </p><p>2.cmd 控制台切换到 github 工程运行指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker-compose up</span><br></pre></td></tr></table></figure><p>3.docker 会自动下载相关 image 并开启服务，一切正常的话通过 Kitematic 可看到 PHP-FPM 和 MySQL Container 服务已经开启，Nginx 服务报错关闭，错误提示与 server.key 及 server.crt 相关。这里遇到的错误是因为 Nginx 启用 443 端口，443端口是默认的 Https 链接端口。由于开启 Https 服务需要本地配置相关证书，此时本地并无相关证书而报错。这里我们忽略 https 相关配置，进入 nginx/conf.d/ 路径，编辑 default.conf 文件，注释以下几行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#    listen  443 ssl;</span><br><span class="line">#    ssl_certificate      /etc/nginx/server.crt;</span><br><span class="line">#    ssl_certificate_key  /etc/nginx/server.key;</span><br><span class="line">#    ssl_protocols        TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">#    ssl_ciphers          HIGH:!aNULL:!MD5;</span><br><span class="line">#    ssl_prefer_server_ciphers  on;</span><br></pre></td></tr></table></figure><p>4.再次执行第2步指令，可见3个 Container 正常开启。</p><p>5.接下来我们会给 PHP-FPM 安装 mysqli 插件，PHP-FPM 通过 mysqli 与 MySQL 进行通信。默认的配置是不包含 mysqli 插件的，编辑 php-fpm/ 路径下的 Dockerfile 文件，增加一行代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">######</span><br><span class="line"># You can install php extensions using docker-php-ext-install</span><br><span class="line">RUN docker-php-ext-install mysqli</span><br><span class="line">######</span><br></pre></td></tr></table></figure></p><p>修改 Dockerfile 文件后需重新 build，执行以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker-compose build</span><br></pre></td></tr></table></figure><p>然后开启服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker-compose up</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker-compose up -d</span><br></pre></td></tr></table></figure><p>6.最终3个服务同时开启，浏览器中输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost</span><br></pre></td></tr></table></figure><p>可打开服务器首页，显示 php 相关信息。</p><p>7.关闭服务可输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose down</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;互联网是一门实践科学，想要学习 PHP 第一要务即搭建 PHP 开发环境，有了开发环境则可边学习边实践，效果比只看视频和教程好很多。博主也是个 PHP 初学者，搭建环境也并不是一番风顺。本文记录了通过 Docker 搭建 LNMP  Web 开发环境过程，以帮助初学者快速搭建一个简单易上手的开发环境。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="https://fedoryx.github.io/categories/web/"/>
    
    
      <category term="php" scheme="https://fedoryx.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>iOS 数据库探究</title>
    <link href="https://fedoryx.github.io/iOS-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A2%E7%A9%B6/"/>
    <id>https://fedoryx.github.io/iOS-数据库探究/</id>
    <published>2017-08-27T03:19:08.000Z</published>
    <updated>2017-08-27T11:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录前段时间调研 iOS 移动数据库的相关知识，主要从数据库的设计及数据库的选取两方面来谈。希望阅读此篇文章后读者能够大致了解移动端数据库的相关内容。本文会不定期更新，有错误请及时指正。</p><a id="more"></a><h2 id="一-数据库分类"><a href="#一-数据库分类" class="headerlink" title="一. 数据库分类"></a>一. 数据库分类</h2><p>首先简单介绍下市面上的具有代表性的几个数据库：</p><ol><li><p>SQLite :</p><blockquote><p><a href="https://zh.wikipedia.org/zh-hans/SQLite" target="_blank" rel="noopener">SQLite</a> 是遵守ACID的关系数据库管理系统，它包含在一个相对小的 C 程式库中。与许多其它数据库管理系统不同，SQLite 不是一个客户端/服务器结构的数据库引擎，而是被集成在用户程序中。</p></blockquote><blockquote><p>SQLite 遵守 ACID，实现了大多数SQL标准。它使用动态的、弱类型的SQL语法。</p></blockquote><p>SQLite 是移动端使用最广泛的嵌入式数据库。</p></li><li><p>FMDB :</p><p><a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a> 是一个轻量级 SQLite 封装库。由于原生 SQLite API 进行数据存储需要使用 C 语言中的函数，操作较复杂，FMDB 则提供了简洁、易用的 API。FMDB 可看作 SQLite 的一个接口封装，是轻量级的，且不提供对象型的数据操作方式。</p></li><li><p>FMDB 衍生类库 ：</p><p>由于 FMDB 功能有限，且不具有 ORM（对象关系映射）特性，因此出现很多基于 FMDB 之上封装的对象型第三方库，提供对象型的数据操作功能。Github 上有一些高星类库，这里不再细说。</p></li><li><p>WCDB ：</p><p><a href="https://github.com/Tencent/wcdb/wiki" target="_blank" rel="noopener">WCDB</a> 是微信团队出品的一个基于 SQLite 的数据库框架。WCDB 具有很多特性，如 WINQ语言、SQLite 采用多线程模式、数据库加密、数据库修复、反注入等等。其使用 C++ 对底层进行了较多的修改。</p></li><li><p>Core Data</p><p>Core Data 是苹果提供的对象型数据库框架，虽然是官方出品，但由于其复杂性应用并不广泛，相关文章可参考<a href="https://objccn.io/issue-4-1/" target="_blank" rel="noopener">《Core Data 概述》</a>,<a href="http://blog.devtang.com/2016/08/04/i-do-not-like-core-data/" target="_blank" rel="noopener">《我为什么不喜欢 Core Data》</a>。</p></li><li><p>Realm ：</p><p>Realm 是由 Y Combinator 孵化的创业团队开源出来的一款可以用于iOS (同样适用于 Swift &amp; Objective-C ) 和 Android 的跨平台移动数据库。其重新设计了数据库核心引擎，定位为高性能、跨平台、简单易用的 ORM 型数据库。Relam 提供了独有的 API 来进行相关数据操作。 </p></li><li><p>CTPersistance</p><p>CTPersistance 是 Casa 大神设计的一个基于 SQLite 封装的数据库框架，在<a href="https://casatwy.com/iosying-yong-jia-gou-tan-ben-di-chi-jiu-hua-fang-an-ji-dong-tai-bu-shu.html" target="_blank" rel="noopener">《iOS应用架构谈 本地持久化方案及动态部署》</a>这篇文章中对其设计思想进行了深度的探讨。个人最喜欢的也是这个数据库，本文第二部分 - 数据库设计 - 很大程度上也是参考了这篇博文的思想，因此将在第二部分进行详述。</p></li></ol><p>以上介绍了几个数据库，下表按照提及的两个主要维度对它们进行直观的划分： </p><table><thead><tr><th></th><th>SQLite</th><th>非SQLite</th></tr></thead><tbody><tr><td>对象型</td><td>CoreData <br> FMDB衍生类库 <br> WCDB <br> CTPersistance</td><td>Realm</td></tr><tr><td>非对象型</td><td>FMDB</td><td>无</td></tr></tbody></table><h2 id="二-数据库设计"><a href="#二-数据库设计" class="headerlink" title="二. 数据库设计"></a>二. 数据库设计</h2><p>这里所说的数据库设计更多的是在思考如果要自己封装一个 ORM 型数据库在架构上应该考虑哪些方面。由于本部分比较抽象概括，为便于理解，建议读者先阅读 Casa 大神的这篇文章<a href="https://casatwy.com/iosying-yong-jia-gou-tan-ben-di-chi-jiu-hua-fang-an-ji-dong-tai-bu-shu.html" target="_blank" rel="noopener">《iOS应用架构谈 本地持久化方案及动态部署》</a> 后再继续阅读。</p><p>我个人觉得数据库框架架构上最看重的是以下两方面（前提这是一款 ORM 型的数据库）：</p><ol><li>业务层与数据层能否解耦</li><li>数据库中对象模型在业务层使用过程中能否保证操作安全</li></ol><h3 id="1-解耦"><a href="#1-解耦" class="headerlink" title="1. 解耦"></a>1. 解耦</h3><p>解耦可以提高程序的维护性、便于移植，在数据库的设计中能否解耦业务层与数据层是很重要的一方面。</p><p>数据库的设计中离不开三个角色：</p><ul><li>数据记录：一条数据记录即数据表中的一行</li><li>数据表：数据表代表了我们设计的一个表的结构，里面包含定义的多个字段</li><li>数据库管理者：数据库管理者即管理数据库的创建、销毁、多线程及 SQL 语句的执行等等</li></ul><p>好的解耦即明晰三个角色的职责，对它们分别进行抽象。数据库管理者是数据库框架核心引擎，属于数据层。数据表是用户定义的数据结构，但其应该是通用的、单一的结构，只含简单的数据操作逻辑，不包含业务逻辑，只是单纯的一张表，其也属于数据层。数据记录是业务层使用的数据结构，属于业务层。</p><p>这里盗用 Casa 文章中的一张结构图，这张图很好的展示了业务层至数据层的整体结构划分。分析下 CTPersistance 是如何做到好的解耦的：</p><ul><li>将数据库逻辑分为强业务逻辑和弱业务逻辑，弱业务逻辑即数据库的增、删、改、查，由图中 Table 负责，强业务逻辑包含数据缓存、数据组装及相关的业务逻辑（如数据分页、筛选等），由图中 DataCenter 负责，提供业务层友好的API。这里 Table 和 DataCenter 没有耦合，是可以独立存在及复用的。</li><li>DataCenter 定义相关 Table，并进行数据表操作，获取需要的数据记录 Record。 Record 和 Table 间通过 Virtual Record 协议进行解耦，实现表中字段与数据记录属性间的 ORM 映射。这样 Table 和 Record 实现解耦，表中的数据可以转换为符合协议的多种对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">                 -------------------------------------------</span><br><span class="line">                 |                                         |</span><br><span class="line">                 |  LogicA     LogicB            LogicC    |-------------------------------&gt; View Layer</span><br><span class="line">                 |     \         /                 |       |</span><br><span class="line">                 -------\-------/------------------|--------</span><br><span class="line">                         \     /                   |</span><br><span class="line">                          \   / Virtual            | Virtual</span><br><span class="line">                           \ /  Record             | Record</span><br><span class="line">                            |                      |</span><br><span class="line">                 -----------|----------------------|--------</span><br><span class="line">                 |          |                      |       |</span><br><span class="line">  Strong Logics  |     DataCenterA            DataCenterB  |</span><br><span class="line">                 |        /   \                    |       |</span><br><span class="line">-----------------|-------/-----\-------------------|-------|    Data Logic Layer   ---</span><br><span class="line">                 |      /       \                  |       |                         |</span><br><span class="line">   Weak Logics   | Table1       Table2           Table     |                         |</span><br><span class="line">                 |      \       /                  |       |                         |</span><br><span class="line">                 --------\-----/-------------------|--------                         |</span><br><span class="line">                          \   /                    |                                 |--&gt; Data Persistance Layer</span><br><span class="line">                           \ / Query Command       | Query Command                   |</span><br><span class="line">                            |                      |                                 |</span><br><span class="line">                 -----------|----------------------|--------                         |</span><br><span class="line">                 |          |                      |       |                         |</span><br><span class="line">                 |          |                      |       |                         |</span><br><span class="line">                 |      DatabaseA              DatabaseB   |  Data Operation Layer ---</span><br><span class="line">                 |                                         |</span><br><span class="line">                 |             Database Pool               |</span><br><span class="line">                 -------------------------------------------</span><br></pre></td></tr></table></figure><p>这里延伸下，iOS 中协议是实现解耦的一大利器，如果开发中有解耦的需求，可考虑通过协议的方式进行。</p><h3 id="2-数据操作安全"><a href="#2-数据操作安全" class="headerlink" title="2. 数据操作安全"></a>2. 数据操作安全</h3><p>由于是对象型数据库，数据表和数据记录其字段是一致的，因此很多数据库的封装并没有区分数据表和数据记录这两个角色，将他们抽象为一个数据对象。常用的操作代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Record *record = [[Record alloc] init];</span><br><span class="line">record.data = @&quot;data&quot;;</span><br><span class="line">[record save];</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Record *record = [[Record alloc] init];</span><br><span class="line">NSArray *result = [record fetchList];</span><br></pre></td></tr></table></figure><p>可以看到 Record 对象在应用中是可以直接修改数据库中的数据，这样很容易造成业务层对象 Record 误操作而修改数据库中数据，是不安全的。因此在使用这类库时建议加一层数据转换层（类似上图 DataCenter的简化版），将 Record 对象转换为数据库无关的对象，避免误操作。</p><p>CTPersistance 由于解耦 Record 和 Table，且 DataCenter 与业务层打交道，而不是通过 Record 对象，因此数据操作是安全的。</p><h2 id="三-数据库选取"><a href="#三-数据库选取" class="headerlink" title="三.数据库选取"></a>三.数据库选取</h2><p>上文介绍了这么多数据库，那么实际应用中到底该如何选取数据库呢？</p><p>如果是个人开发者，功能不复杂，追求开发速度的话 Realm 比较合适，其简单易上手，有专门团队加持，开发文档、工具也相对完善。当然 Realm 自成一派，以后想切换到 SQLite 系数据库就得重新开始。同时 Realm 中数据库对象都必须继承于 Realm Object，iOS 开发中类有单继承的限制，应用过程中也需要考虑到这点。</p><p>如果是团队比较强大，有人力来钻研开源代码，可以参考下 WCDB，功能强大，但技术要求比较高，应用成本较高。</p><p>我推荐的还是 CTPersistance ，比较欣赏其设计思想，框架解耦且数据库基本功能都具备，也很容易在其上进行功能拓展，同时技术栈难度适合。当然更推荐团队开发借鉴这种思想开发或优化自己的框架，因为数据库涉及的方面很多，不同业务场景下的要求也不尽相同，常听到的一句话就是技术没有最好的，只有最适合的，是吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录前段时间调研 iOS 移动数据库的相关知识，主要从数据库的设计及数据库的选取两方面来谈。希望阅读此篇文章后读者能够大致了解移动端数据库的相关内容。本文会不定期更新，有错误请及时指正。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://fedoryx.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://fedoryx.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>如何写好技术博客</title>
    <link href="https://fedoryx.github.io/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    <id>https://fedoryx.github.io/如何写好技术博客/</id>
    <published>2017-06-11T01:50:33.000Z</published>
    <updated>2017-06-11T08:37:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何写好技术博客，主要涉及博客文章排版及博客写作心得。</p><a id="more"></a><h2 id="文章排版"><a href="#文章排版" class="headerlink" title="文章排版"></a>文章排版</h2><p>这部分内容主要参考 <a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">《中文文案排版指北》</a>，<a href="https://sspai.com/post/37815" target="_blank" rel="noopener">《少数派写作排版指南》</a>，<a href="https://zhuanlan.zhihu.com/p/20506092" target="_blank" rel="noopener">写给大家看的中文排版指南</a>。</p><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>1.行文时，请在中文与英文、中文与数字、英文与数字之间增加空格。例如：</p><ul><li><strong>推荐：</strong>苹果公司在 2015 年 9 月 9 日发布了 iPhone 6s。</li><li><strong>不推荐：</strong>苹果公司在2015年9月9日发布了iPhone 6s。</li></ul><p>2.一段文字中有超链接的部分，在超链接的前后使用空格。例如：</p><ul><li><strong>推荐</strong>你可以前往 <a href>苹果官网</a> 了解详情</li><li><strong>不推荐</strong>你可以前往<a href>苹果官网</a>了解详情</li></ul><p>3.英文、数字前后接全角标点符号或者表示单位的角标符号时，不需要加空格。例如：</p><ul><li><strong>正确：</strong>新款屏幕的可视角度为 125°，相比旧款提升了 25%。</li><li><strong>错误：</strong>新款屏幕的可视角度为 125 °，相比旧款提升了 25 %。</li></ul><p>4.对于有特殊用法的专有名词，如 4K、1080p、iOS 10 等，英文和数字之间是否空格以官方标准为准。</p><p>5.每段文字的开头不需要空两格。</p><h2 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h2><p>1.引号请使用直角引号「」，而不是弯引号  “”。</p><p>2.引号中再引号使用双直角引号『』。</p><p>3.当引号表示讽刺、反语暗示时，使用弯引号。</p><blockquote><p>示例：说真的，我也很 “喜欢”「苹果表」哦。</p></blockquote><p>4.省略号请使用 …… 标准用法，正确输入方法是 shift + 6。不要使用三个句号。。。，也不要使用三个英文句点 …。</p><p>5.不重复使用标点符号。</p><p>6.破折号占两个汉字空间。</p><blockquote><p>示例：中国设计还有太长路要走————加油罢。</p></blockquote><h2 id="中文和西文符号"><a href="#中文和西文符号" class="headerlink" title="中文和西文符号"></a>中文和西文符号</h2><p>1.一般情况下，一个中文句子中出现了英文部分，仍然使用中文标点，即全角符号。例如：</p><ul><li><strong>正确：</strong>我常用的电子设备是 Kindle、iPad Pro、iPhone。</li><li><strong>错误：</strong>我常用的电子设备是 Kindle, iPad Pro, iPhone.</li></ul><p>2.如果引用一段完整的英文句子，或是出现在专有名词中的标点，则不需要更改标点符号。例如：</p><ul><li><strong>正确：</strong>乔布斯说「Stay hungry, Stay foolish.」</li><li><strong>错误：</strong>乔布斯说「Stay hungry，Stay foolish。」</li><li><strong>正确：</strong>我最喜欢的手机游戏是 Lifeline: Silent Night。</li><li><strong>错误：</strong>我最喜欢的手机游戏是 Lifeline：Silent Night。</li></ul><h2 id="注明引用来源"><a href="#注明引用来源" class="headerlink" title="注明引用来源"></a>注明引用来源</h2><p>1.文中有使用外站或外部内容的，务必在引用最后部分注明来源。</p><p>2.文中有使用外站图片，必须在文末标明。来源如果来自外站必须添加链接。例如：</p><ul><li>本文部分图片来自 <a href>The Verge</a></li><li>题图来自电影《春娇与志明》截图</li></ul><p>3.若文章为全文翻译，必须在文中注明原作者及原文地址，并添加原文链接。</p><h2 id="博客风格"><a href="#博客风格" class="headerlink" title="博客风格"></a>博客风格</h2><p>1.用主动语态，不要用被动语态。一般情况下，主动语态比被动语态更有力。</p><ul><li><strong>主动语态：</strong>I read the book.</li><li><strong>被动语态：</strong>The book is read by me.</li></ul><p>2.一图胜千言！</p><p>3.使用具体、明确、展示细节的词汇，能激发想象，使读者自己代入情境。「把硬币放进口袋里，他咧开嘴笑了」，远远强过「他满意地拿走了辛苦挣来的奖赏」。</p><p>4.减少形容词的使用，少用 「的」。</p><p>5.忌罗列代码。</p><h2 id="如何写好技术博客"><a href="#如何写好技术博客" class="headerlink" title="如何写好技术博客"></a>如何写好技术博客</h2><p>这里主要摘录一些网络博主的高见，我也要在写作过程中慢慢体会。</p><h3 id="目的明确"><a href="#目的明确" class="headerlink" title="目的明确"></a>目的明确</h3><p>明确博客目的，通常是学习一项技术、解决一个问题、记录一些过程。博客主题要明确，分清主次，不要毕其功于一役。次要问题可单独成篇。</p><h3 id="博客是总结，不是过程"><a href="#博客是总结，不是过程" class="headerlink" title="博客是总结，不是过程"></a>博客是总结，不是过程</h3><p>参考如下步骤写博客：</p><ul><li>碰到问题，决定是否有价值写为博客，若有则进行记录，作为一篇博客的开篇。</li><li>首先，先自己分析问题，基于已有的现象，思考，在笔记本上记录问题与可能的思路。</li><li>其次，从外界获取经验或者知识，比如请教别人，Google等，学习他们，在笔记本上记录关键点。</li><li>然后，在实际中用学来的方法去解决问题，笔记本做好记录，要像水流过水渠一样流淌前面记录的思路。</li><li>最后，拿过笔记本，将以上过程再总结成一篇博客。将解决问题的思路进行深化或拓展，也可引出新的博客篇章。</li></ul><p>知识开始学习的时候，经常是只见树木，不见森林。俗话说：”孤木不成林“，弄上三五棵树，才会有”森林“的感觉。</p><h3 id="尽量拒绝三手技术"><a href="#尽量拒绝三手技术" class="headerlink" title="尽量拒绝三手技术"></a>尽量拒绝三手技术</h3><p>以官方文档、实验验证为主。</p><h3 id="博客的知识层次"><a href="#博客的知识层次" class="headerlink" title="博客的知识层次"></a>博客的知识层次</h3><ul><li>听说过该技术，了解该技术解决什么问题；</li><li>使用过该技术，熟悉该技术的使用方法；</li><li>解构过该技术，熟悉该技术的架构、原理；</li><li>贯通过该技术，将该技术与自己的以有知识完全融合，可以利用该技术架构或解决其他问题。</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>1.<a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener">中文文案排版指北</a></p><p>2.<a href="https://sspai.com/post/37815" target="_blank" rel="noopener">少数派写作排版指南</a></p><p>3.<a href="https://zhuanlan.zhihu.com/p/20506092" target="_blank" rel="noopener">写给大家看的中文排版指南</a></p><p>4.<a href="http://rock3.info/blog/2013/11/26/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E7%AF%87%E5%A5%BD%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">如何写一篇好的技术博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍如何写好技术博客，主要涉及博客文章排版及博客写作心得。&lt;/p&gt;
    
    </summary>
    
      <category term="博客" scheme="https://fedoryx.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="https://fedoryx.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>iTerm2 + Oh My Zsh -- MAC篇</title>
    <link href="https://fedoryx.github.io/iTerm2-Oh-My-Zsh-MAC%E7%AF%87/"/>
    <id>https://fedoryx.github.io/iTerm2-Oh-My-Zsh-MAC篇/</id>
    <published>2017-06-10T10:00:00.000Z</published>
    <updated>2017-06-11T08:28:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前看到过几篇关于提升程序员效率的文章 <a href="https://www.zhihu.com/question/20873070" target="_blank" rel="noopener">《程序员如何优雅使用MAC》</a>，<a href="http://www.jianshu.com/p/2b072b206c90" target="_blank" rel="noopener">《如何大幅度提高 Mac 开发效率》</a>，其中都涉及改造你的 Terminal 相关内容。本文即介绍如何通过 Iterm2 + Oh My Zsh + PowerLine 彻底改造你的 Terminal，提升效率。</p><a id="more"></a><p>最终效果图：</p><img src="/iTerm2-Oh-My-Zsh-MAC篇/iTerm2.png" title="效果图"><h2 id="一-安装-iTerm2"><a href="#一-安装-iTerm2" class="headerlink" title="一 安装 iTerm2"></a>一 安装 iTerm2</h2><p><a href="http://www.iterm2.com" target="_blank" rel="noopener">官网</a> 下载。</p><h2 id="二-zsh"><a href="#二-zsh" class="headerlink" title="二 zsh"></a>二 zsh</h2><p>不清楚 zsh 的同学可前往 <a href="http://macshuo.com/?p=676" target="_blank" rel="noopener">终极 Shell-zsh </a> 这篇文章了解下 shell 和 zsh。</p><p>MAC 中自带zsh，不用安装，可通过命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/shells</span><br></pre></td></tr></table></figure><p>显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure><h2 id="三-安装-Oh-My-Zsh"><a href="#三-安装-Oh-My-Zsh" class="headerlink" title="三 安装 Oh My Zsh"></a>三 安装 Oh My Zsh</h2><p><a href="http://ohmyz.sh" target="_blank" rel="noopener">Oh My Zsh 官网</a> 列举两种安装方式：</p><p><strong>curl</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><p><strong>wget</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure><h2 id="四-Oh-My-Zsh-主题"><a href="#四-Oh-My-Zsh-主题" class="headerlink" title="四 Oh My Zsh 主题"></a>四 Oh My Zsh 主题</h2><p>Oh My Zsh 默认主题是「robbyrussell」，以下操作将主题修改为「agnoster」，也是目前使用最广泛的主题。</p><p>打开 zshrc 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~/.zshrc</span><br></pre></td></tr></table></figure><p>把里面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=&quot;robbyrussell&quot;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=&quot;agnoster&quot;</span><br></pre></td></tr></table></figure><p>然后退出编辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ :wq</span><br></pre></td></tr></table></figure><p>重启 iTerm2。</p><h2 id="五-安装-Powerline-及字体"><a href="#五-安装-Powerline-及字体" class="headerlink" title="五 安装 Powerline 及字体"></a>五 安装 Powerline 及字体</h2><p>Powerline 是一个 stateless status line，即一个全局状态/提示栏。详细资料可参考 <a href="http://cenalulu.github.io/linux/mac-powerline/" target="_blank" rel="noopener">《为Bash和VIM配置一个美观奢华的状态提示栏》</a> 这篇文章。</p><p>通过 pip 安装 Powerline</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install powerline-status</span><br></pre></td></tr></table></figure><p>若报权限错误，可执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install powerline-status --user -U</span><br></pre></td></tr></table></figure><p><a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">powerline 字体合集</a> 有很多 powerline 字体，若想采用 Menlo 和 Monaco 可前往 <a href="https://github.com/supermarin/powerline-fonts" target="_blank" rel="noopener"> supermarin Github </a>。下载后双击 otf 字体文件安装。</p><h2 id="六-iTerm2-配置"><a href="#六-iTerm2-配置" class="headerlink" title="六 iTerm2 配置"></a>六 iTerm2 配置</h2><p>进入 iTerm2 的 Preference - Profile - Colors 调整配色方案，选择 Solarized Dark 或 Solarized Light。</p><p>进入 Text 栏更改字体为 Manaco powerline。建议把 Text Rendering 里的 Drew bold text in bright colors 给去掉，否则会影响列表着色。</p><h2 id="Congratulations！"><a href="#Congratulations！" class="headerlink" title="Congratulations！"></a>Congratulations！</h2><p>至此大功告成！</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>1.<a href="https://www.zhihu.com/question/20873070" target="_blank" rel="noopener">《程序员如何优雅使用MAC》</a></p><p>2.<a href="http://www.jianshu.com/p/2b072b206c90" target="_blank" rel="noopener">《如何大幅度提高 Mac 开发效率》</a></p><p>3.<a href="http://macshuo.com/?p=676" target="_blank" rel="noopener">终极 Shell-zsh</a></p><p>4.<a href="http://www.qiangblog.com/post/mac/macxia-pei-zhi-iterm2-oh-my-zsh" target="_blank" rel="noopener">Mac下配置iTerm2+oh-my-zsh</a></p><p>5.<a href="http://cenalulu.github.io/linux/mac-powerline/" target="_blank" rel="noopener">《为Bash和VIM配置一个美观奢华的状态提示栏》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前看到过几篇关于提升程序员效率的文章 &lt;a href=&quot;https://www.zhihu.com/question/20873070&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《程序员如何优雅使用MAC》&lt;/a&gt;，&lt;a href=&quot;http://www.jianshu.com/p/2b072b206c90&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《如何大幅度提高 Mac 开发效率》&lt;/a&gt;，其中都涉及改造你的 Terminal 相关内容。本文即介绍如何通过 Iterm2 + Oh My Zsh + PowerLine 彻底改造你的 Terminal，提升效率。&lt;/p&gt;
    
    </summary>
    
      <category term="效率" scheme="https://fedoryx.github.io/categories/%E6%95%88%E7%8E%87/"/>
    
    
      <category term="iTerm2" scheme="https://fedoryx.github.io/tags/iTerm2/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客搜索 SEO 优化 -- 谷歌篇</title>
    <link href="https://fedoryx.github.io/Hexo-%E5%8D%9A%E5%AE%A2%E6%90%9C%E7%B4%A2-SEO-%E4%BC%98%E5%8C%96-%E8%B0%B7%E6%AD%8C%E7%AF%87/"/>
    <id>https://fedoryx.github.io/Hexo-博客搜索-SEO-优化-谷歌篇/</id>
    <published>2017-06-08T01:50:33.000Z</published>
    <updated>2017-06-11T07:55:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍博客搜索 SEO 优化的相关知识，博客系统采用 Hexo 框架，Next 主题。 </p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>辛辛苦苦写的博客不能被搜索引擎发现岂不可惜，好东西还是希望让更多的人看到（满足下小小的虚荣心）。因此就引出了博客的 SEO（Search Engine Optimization） 搜索优化这篇博文。</p><p>SEO 毕竟是很专业的事情，阅读本文后尽量使读者达到如下效果：</p><ul><li>博客文章可被 Google 搜索到</li><li>博客文章在 Google 搜索排名靠前</li><li>SEO 知识拓展</li></ul><h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><p>SEO（Search Engine Optimization）即搜索引擎优化，<a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E5%BC%95%E6%93%8E%E6%9C%80%E4%BD%B3%E5%8C%96" target="_blank" rel="noopener">维基百科</a> 上给出的定义如下：</p><blockquote><p>搜索引擎优化是一种通过了解搜索引擎的运作规则来调整网站，以及提高目的网站在有关搜索引擎内排名的方式。</p></blockquote><p>个人理解 SEO 可从两方面入手：</p><p>1.技术手段：</p><p>通过研究搜索引擎的规则，利用某些技巧提升 SEO 效果；</p><p>2.内容质量：</p><p>内容质量是更长久的提升SEO效果的核心，这里直接引用维基百科中的内容：</p><blockquote><p>站点经常地更新，有用、原创的内容，和创建几个实用、有意义的导入链接，获得相当可观数目的基本搜索流量不是什么难事。</p><p>当站点拥有有用的内容，其它站点员自然而然会链接至该站，进而增加访客它的网页级别和访客流。当访客发现一个有用的网站，他们倾向于利用电子邮件或者及时消息链接介绍给其它访客。</p><p>总括来说，增进网站质量的搜索引擎优化实现很可能比直接查找操控搜索排名手段的短期实现要活得长久。顶尖的搜索引擎优化员们找寻的目标与搜索引擎追求发扬光大的东西二者不约而同。他们是：相关性、对他们用户有用的内容。换句话说，即向用户提供优质有用，而且独特的数据，以内容营销的方法，软性地吸引潜在的客户，自自然然地找到你的网页。</p></blockquote><p>以上简单介绍 SEO 概念及优化，博客内容质量的提升应该是我们每个博主共同的愿景，需要长久的坚持和创作，本文并不细数。接下来介绍Hexo 博客 SEO 优化的一些技巧。</p><h2 id="让-Google-找到你的博客"><a href="#让-Google-找到你的博客" class="headerlink" title="让 Google 找到你的博客"></a>让 Google 找到你的博客</h2><h3 id="验证网站"><a href="#验证网站" class="headerlink" title="验证网站"></a>验证网站</h3><h4 id="1-查看是否被收录"><a href="#1-查看是否被收录" class="headerlink" title="1 查看是否被收录"></a>1 查看是否被收录</h4><p>打开谷歌搜索，在搜索框里输入自己的博客 URL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site: https://fedoryx.github.io/</span><br></pre></td></tr></table></figure><p>如果提示说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找不到和您查询的 site:https://fedoryx.github.io</span><br></pre></td></tr></table></figure><p>说明未被收录。</p><p>我遇到的情况是博客搭建好后谷歌是不会自动收录的。</p><h4 id="2-Google-Search-Console-提交网站"><a href="#2-Google-Search-Console-提交网站" class="headerlink" title="2 Google Search Console 提交网站"></a>2 Google Search Console 提交网站</h4><p>若未被谷歌收录，则需在谷歌搜索进行配置。前往 <a href="https://www.google.com/webmasters/tools/home?hl=zh-CN&amp;pli=1" target="_blank" rel="noopener">Google Search Console</a>，登录谷歌账号。</p><p>添加属性，将博客地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:https://fedoryx.github.io/</span><br></pre></td></tr></table></figure></p><p>添至相应位置。</p><p>谷歌搜索有多种验证方式，这里我选择谷歌推荐的 HTML 文件上传方式。下载 HTML 验证文件，拷贝到 Hexo/sources/ 文件夹下。</p><h4 id="3-添加站点地图"><a href="#3-添加站点地图" class="headerlink" title="3 添加站点地图"></a>3 添加站点地图</h4><p>作用：告诉搜索引擎你的网站结构等信息，让搜索引擎更智能抓取内容。</p><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><p>打开 Git Shell，进入到 Hexo 目录，输入如下命令安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><p>打开 Hexo 目录下的 _config.yml 文件，在最下方添加如下字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 自动生成sitemap</span><br><span class="line">sitemap:</span><br><span class="line">path: sitemap.xml</span><br></pre></td></tr></table></figure><p>然后重新编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>重新部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h5 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h5><p>进入 Google Search Console - 抓取 - 站点地图，点击「添加/测试站点地图」，输入你的博客网址。若无报错则站点地图提交成功</p><h3 id="提交-robots-txt"><a href="#提交-robots-txt" class="headerlink" title="提交 robots.txt"></a>提交 robots.txt</h3><p>robots.txt 是一种存放于网站根目录下的 ASCII 编码的文本文件，它的作用是告诉搜索引擎此网站中哪些内容是可以被爬取的，哪些是禁止爬取的。robots.txt 放在博客目录下的 source 文件夹中，博客生成后在站点目录 /public/ 下。</p><p>我的 robots.txt 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /about/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br></pre></td></tr></table></figure><p>robots.txt 文件更新至网站后可进入 Google Search Console - 抓取 - robots.txt 测试工具进行测试。</p><h3 id="Google-抓取工具"><a href="#Google-抓取工具" class="headerlink" title="Google 抓取工具"></a>Google 抓取工具</h3><p>利用 Google 抓取工具可以测试 Google 会如何抓取或呈现您的网站上某个网址。</p><p>进入Google Search Console - 抓取 - Google 抓取工具 ，在这里填上需要抓取的  URL，不填表示抓取首页。抓取方式可以选择桌面、智能手机等等，自行根据需要选择。填好 URL 之后，点击抓取。然后可能会出现几种情况，如:完成、部分完成、重定向等，这三种情况是可以提交的。</p><p>提交完成后，提交至索引，根据提示操作就可以了，我的提交：</p><p>SEO 中抓取和索引知识可参考 <a href="http://www.yesharris.com/crawl-and-index/" target="_blank" rel="noopener">SEO基礎課程：認識抓取 (Crawl) 與索引 ( Index )</a>这篇文章。</p><p>以上就是 Google Search Console 的相关配置，完成后可搜索博客首页或文章标题进行测试是否被谷歌收录。</p><h2 id="提升-Google-搜索排名"><a href="#提升-Google-搜索排名" class="headerlink" title="提升 Google 搜索排名"></a>提升 Google 搜索排名</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>博客根目录 _config.yml 文件进行如下修改，关键字英文逗号隔开：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 网站名称</span><br><span class="line">description: 网站描述</span><br><span class="line">author: 作者姓名</span><br><span class="line">subtitle: 作者简介</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone:</span><br><span class="line">keywords: Web,HTML # 博客关键字</span><br></pre></td></tr></table></figure><p>文章中加入关键字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: ###</span><br><span class="line">date: ###</span><br><span class="line">categories: ###</span><br><span class="line">tags: ###</span><br><span class="line">keywords: ###</span><br><span class="line">description: ###</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h3 id="文章路径简化"><a href="#文章路径简化" class="headerlink" title="文章路径简化"></a>文章路径简化</h3><p>Hexo 默认的文章链接形式为 domain/year/month/day/postname，默认就是一个四级 url，并且可能造成 url 过长，对搜索引擎是十分不友好的。我们可以改成 domain/postname 的形式。编辑站点 _config.yml 文件，修改其中的 permalink 字段改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink: :title.html</span><br></pre></td></tr></table></figure><h3 id="添加-nofollow-标签"><a href="#添加-nofollow-标签" class="headerlink" title="添加 nofollow 标签"></a>添加 nofollow 标签</h3><p>给非友情链接的出站链接添加「nofollow」标签，nofollow 标签是由谷歌领头创新的一个「反垃圾链接」的标签，并被百度、yahoo 等各大搜索引擎广泛支持，引用 nofollow 标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有 nofollow 属性的任何出站链接，以减少垃圾链接的分散网站权重。</p><p>1.修改 footer.swig（your-hexo-site\themes\next\layout_partials)</p><p>将下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; href=&quot;http://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; href=&quot;http://hexo.io&quot; rel=&quot;external nofollow&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;</span><br></pre></td></tr></table></figure><p>将下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot; rel=&quot;external nofollow&quot;&gt;</span><br></pre></td></tr></table></figure><p>2.修改 sidebar.swig（your-hexo-site\themes\next\layout_macro）</p><p>将下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>将下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot;&gt;</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;</span><br></pre></td></tr></table></figure><p>优化都完成后可通过谷歌搜索文章标题，测试是否被收录及排名。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>1.<a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E5%BC%95%E6%93%8E%E6%9C%80%E4%BD%B3%E5%8C%96" target="_blank" rel="noopener">维基百科 SEO </a></p><p>2.<a href="http://www.jeyzhang.com/hexo-website-seo.html" target="_blank" rel="noopener">Hexo网站优化之SEO</a></p><p>3.<a href="http://www.ehcoo.com/seo.html" target="_blank" rel="noopener">Hexo-next百度和谷歌搜索优化</a></p><p>4.<a href="http://www.yesharris.com/crawl-and-index/" target="_blank" rel="noopener">SEO基礎課程：認識抓取 (Crawl) 與索引 ( Index )</a></p><p>5.<a href="http://www.arao.me/2015/hexo-next-theme-optimize-seo/" target="_blank" rel="noopener">动动手指，不限于NexT主题的Hexo优化（SEO篇</a></p><p>6.<a href="http://www.arao.me/2015/hexo-next-theme-optimize-base/#hexo_NexT主题首页title的优化" target="_blank" rel="noopener">动动手指，NexT主题与Hexo更搭哦（基础篇）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍博客搜索 SEO 优化的相关知识，博客系统采用 Hexo 框架，Next 主题。 &lt;/p&gt;
    
    </summary>
    
      <category term="博客" scheme="https://fedoryx.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="SEO,博客" scheme="https://fedoryx.github.io/tags/SEO-%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>利用 GitHub + Hexo + Docker 快速构建独立博客 -- MAC篇</title>
    <link href="https://fedoryx.github.io/%E5%88%A9%E7%94%A8-GitHub-Hexo-Docker-%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2-MAC%E7%AF%87/"/>
    <id>https://fedoryx.github.io/利用-GitHub-Hexo-Docker-快速构建独立博客-MAC篇/</id>
    <published>2017-06-04T01:50:33.000Z</published>
    <updated>2017-06-11T08:28:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了 MAC 环境下搭建独立博客的完整过程，最初的方案是 Github + Hexo，之后引入 Docker。此博客搭建方案的特点是快速、独立、免费、高自由度。本博客网站即是由此方案搭建而成，博客主题为 Next。</p><a id="more"></a><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>1.GitHub  &amp; Git</p><h2 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h2><p>首先给出 Blog 系统的整体结构。结构图如下所示：</p><img src="/利用-GitHub-Hexo-Docker-快速构建独立博客-MAC篇/Docker_blog_structure.png" title="结构图"><p>图中结构大致分为3部分：</p><p>1.宿主机<br>宿主机即 MAC，主要完成资源配置文件挂载及环境配置。挂载文件如下：</p><ul><li>_config.yml</li><li>themes</li><li>source</li><li>.ssh</li></ul><p>2.Docker<br>Docker 是 Blog 系统的核心，使用配置好的 Hexo-Docker Image 创建两个 Container，Hexo-server 负责预览，Hexo-deploy 执行部署。</p><p>3.GitHub Pages  &amp;&amp; 本地预览<br>GitHub Pages 实现网络博客展示，本地打开 Local：4000 地址实现预览。</p><p>这里建立 Blog 系统的初步印象，下文将详细描述博客的完整搭建过程。</p><p>博主本着授人以鱼不如授人以渔的观念，文中很多地方给出了参考链接，若文章中描述不清楚请移步至参考文档，会有更深的理解。</p><h1 id="一-GitHub-Pages"><a href="#一-GitHub-Pages" class="headerlink" title="一. GitHub Pages"></a>一. GitHub Pages</h1><p>想拥有自己的博客会是什么心路历程呢？</p><blockquote><p>喜欢写 Blog 的人，会经历三个阶段。</p><p>第一阶段，刚接触 Blog，觉得很新鲜，试着选择一个免费空间来写。</p><p>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</p><p>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p><p>《 <a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">引自 阮一峰</a> 》</p></blockquote><p>帮助你达到第三阶段的利器就是 <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>。</p><h2 id="GitHub-Pages-是什么："><a href="#GitHub-Pages-是什么：" class="headerlink" title="GitHub Pages 是什么："></a>GitHub Pages 是什么：</h2><p>GitHub Pages 可以被认为是用户编写的、托管在 GitHub 上的<strong>静态网页</strong>。</p><h2 id="GitHub-Pages-的优势："><a href="#GitHub-Pages-的优势：" class="headerlink" title="GitHub Pages 的优势："></a>GitHub Pages 的优势：</h2><ul><li>免费</li><li>无限流量</li><li>全世界理想的访问速度</li></ul><h2 id="GitHub-Pages-注意点："><a href="#GitHub-Pages-注意点：" class="headerlink" title="GitHub Pages 注意点："></a>GitHub Pages 注意点：</h2><ol><li>GitHub Pages 仓库名命名格式一定为 用户名.github.io，用户名是你的 GitHub 账户用户名。</li><li>博客内容一定是在 Master 分支下。</li><li>博客搭建好后可以通过 http://用户名.github.io 地址来访问博客主页。</li></ol><p>详细的内容参考 <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages官方主页</a>。</p><h1 id="二-Hexo"><a href="#二-Hexo" class="headerlink" title="二. Hexo"></a>二. Hexo</h1><h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><ul><li><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">官方</a> 定义：快速、简洁且高效的博客框架</li><li>另一种说法：Hexo 是一个轻量的静态博客框架。 </li><li>博主扯淡：Hexo 是一个工具，借助它我们可以配置博客的主题、样式，可以通过插件增强博客的功能，可以编写及管理文章，可以预览博客以及部署博客至 GitHub Pages。</li></ul><p>到此结束。</p><p>哈哈，看到这里是不是想打作者了，其实是作者对 Hexo 也不是完全精通，但这并不妨碍搭建自己的博客。很多文章介绍了如何一步步搭建 Hexo 的开发环境，咱们由于使用了 Docker 这个神兵利器，一些基础环境的搭建真的是轻松太多了，因此这部分挑重点讲讲 Hexo，具体的环境搭建等 Docker 部分再详细介绍。这部分也可以先忽略，后文中遇到 Hexo 的部分不懂的再来看。</p><h2 id="Hexo-搭建准备"><a href="#Hexo-搭建准备" class="headerlink" title="Hexo 搭建准备"></a>Hexo 搭建准备</h2><ul><li><p>Node.js</p></li><li><p>Git</p></li></ul><p>当然，有了 Docker，就不需要自己建立 Node.js 环境，Git 环境开发者必备。</p><h2 id="Hexo-配置方法"><a href="#Hexo-配置方法" class="headerlink" title="Hexo 配置方法"></a>Hexo 配置方法</h2><p>当 Hexo 初始化一个项目成功后，我们会在目录下看到一些文件夹，这里介绍几个重要的配置文件。</p><ul><li>_config.yml 全局配置文件</li><li>themes 存放主题的文件夹</li><li>source 博客资源文件夹</li></ul><h2 id="Hexo-重要命令"><a href="#Hexo-重要命令" class="headerlink" title="Hexo 重要命令"></a>Hexo 重要命令</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>生成静态文件。</p><p>该命令可以简写为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 。</p><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>部署网站。</p><p>该命令可以简写为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>详细的命令介绍可以参考 <a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="Hexo的部署"><a href="#Hexo的部署" class="headerlink" title="Hexo的部署"></a>Hexo的部署</h2><p>Hexo 可以部署到很多平台，这里重点剖析下 Hexo 部署到 GitHub Pages 的原理。</p><p>之前在 GitHub上 创建的 repo（用户名.github.io）一个最大的特点就是其 Master 分支中的 html 静态文件，可以通过链接 http://用户名.github.io 来直接访问。</p><p>Hexo -g 会生成一个静态网站（第一次会生成一个 public 目录），这个静态文件可以直接访问。</p><p>需要将 Hexo 生成的静态网站，提交( git commit )到 GitHub 上，即完成部署。</p><h2 id="本章重要参考："><a href="#本章重要参考：" class="headerlink" title="本章重要参考："></a>本章重要参考：</h2><p>1.<a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="noopener">手把手教你使用 Hexo + Github Pages 搭建个人独立博客</a></p><p>2.<a href="http://jeasonstudio.github.io/2016/05/26/Mac%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EGitHub-Page%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">Mac 上搭建基于 GitHub Page 的 Hexo 博客</a></p><p>3.<a href="http://henrydong.com/2016/01/17/%E5%9F%BA%E4%BA%8ENode-js%E7%9A%84Github-Pages%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">基于 Node.js 的 Github Pages 博客系统</a></p><h1 id="三-Docker"><a href="#三-Docker" class="headerlink" title="三. Docker"></a>三. Docker</h1><h2 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h2><p>什么是 <a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a>？</p><p>官方说法：</p><blockquote><p>Docker is the world’s leading software container platform. Developers use Docker to eliminate “works on my machine” problems when collaborating on code with co-workers. Operators use Docker to run and manage apps side-by-side in isolated containers to get better compute density. Enterprises use Docker to build agile software delivery pipelines to ship new features faster, more securely and with confidence for both Linux and Windows Server apps.</p></blockquote><p>博主 BiBi: </p><blockquote><p>Docker 是一种虚拟化技术，利用 Docker 可以创建或使用容器。<br>容器是什么呢？<br>容器可以想象成一个黑盒子，盒子中放着基于 Linux 的各种系统、平台、环境、工具等等，一次生成，随地使用，也就是通过虚拟化技术跨平台使用容器，同时同一个容器在 Mac OSX、Linux、Windows 等不同平台的表象一致。<br>另外，容器可以挂载文件或目录到宿主机（容器在虚拟环境运行，宿主机即用户环境），用户环境操作这些挂载的文件等同于虚拟环境操作，反之亦然。当然，也可以通过容器中的控制台来在虚拟环境操作。</p></blockquote><p>Docker 中最基本的概念是 Image（镜像）和 Container（容器）。镜像和容器的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。同一个 Images 可生成多个不同配置的 Container。</p><p>详细资料请参考 <a href="https://www.docker.com/" target="_blank" rel="noopener">Docker官网</a>、<a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/why.html" target="_blank" rel="noopener">《Docker-从入门到实践》</a>。</p><h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><h3 id="Docker-For-Mac-下载："><a href="#Docker-For-Mac-下载：" class="headerlink" title="Docker For Mac 下载："></a>Docker For Mac 下载：</h3><p><a href="https://www.docker.com/community-edition" target="_blank" rel="noopener">官网</a> 下载 Docker For Mac CE 版本，企业版是付费的。</p><p>Docker For Mac CE 是 Docker 最新的安装程序，性能好，很多博客中提到的其他安装方法可以忽略。</p><h3 id="Kitematic-下载"><a href="#Kitematic-下载" class="headerlink" title="Kitematic 下载"></a>Kitematic 下载</h3><p>Kitematic 是 Docker可视化程序，不用从 Google 搜，安装好 Docker 后 Docker 图标的下拉菜单中可以找到下载方式，相信你一定能找到的。</p><h2 id="Docker-Hexo-Image"><a href="#Docker-Hexo-Image" class="headerlink" title="Docker-Hexo Image"></a>Docker-Hexo Image</h2><p>两种方式：</p><p>1.安装完毕Docker后我们可拉取公开的 Image，博主用的 Docker-Hexo 镜像，执行以下指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull iyannik0215/docker-hexo</span><br></pre></td></tr></table></figure><p>2.下载 <a href="https://github.com/yakumioto/docker-hexo" target="_blank" rel="noopener">Docker-Hexo github</a> 中./3.2/alpine/ 下的 DockerFile 文件和脚本自行构建 Docker Image。</p><p>新建目录 /Hexo，将下载的 DockerFile 和脚本移动至该文件夹下。命令台切换至 /Hexo 路径下，运行以下指令生成 Docker Image。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t xxx/hexo .</span><br></pre></td></tr></table></figure><p>xxx/hexo 是你定义的Image名称，还有千万别忘了后面的 <strong>.</strong> !!!</p><p>博主试了获取镜像的第一种方法，在之后的过程中会报错，因此用的第二种方式。大家可以都试试看。</p><h2 id="Docker-Hexo-Container"><a href="#Docker-Hexo-Container" class="headerlink" title="Docker-Hexo Container"></a>Docker-Hexo Container</h2><h3 id="指令生成hexo-server-Container："><a href="#指令生成hexo-server-Container：" class="headerlink" title="指令生成hexo-server Container："></a>指令生成hexo-server Container：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 4000:80 --name hexo-server -d \</span><br><span class="line">-v &#123;你的博客文件夹路径&#125;/.ssh:/root/.ssh \</span><br><span class="line">-v &#123;你的博客文件夹路径&#125;/source:/Hexo/source \</span><br><span class="line">-v &#123;你的博客文件夹路径&#125;/themes:/Hexo/themes \</span><br><span class="line">-v &#123;你的博客文件夹路径&#125;/_config.yml:/Hexo/_config.yml \</span><br><span class="line">xxx/hexo &#123;你的 github username&#125; &#123;你的 github email&#125; s</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>{你的博客文件夹路径} 即你新建的目录 /Hexo </li><li>命令中的 xxx/hexo 即上一步的Image名称</li><li>命令中的-v即挂载文件指令</li><li>博主将系统的.ssh文件拷贝至该目录，这样避免容器意外修改系统.ssh文件</li></ul><p>Kitematic 中可看到 hexo-server container 正在执行，点击 exec 可进入 container 控制台。</p><h3 id="指令生成-hexo-deploy-Container："><a href="#指令生成-hexo-deploy-Container：" class="headerlink" title="指令生成 hexo-deploy Container："></a>指令生成 hexo-deploy Container：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 4000:80 --name hexo-deploy -d \</span><br><span class="line">*v &#123;你的博客文件夹路径&#125;/.ssh:/root/.ssh \</span><br><span class="line">*v &#123;你的博客文件夹路径&#125;/source:/Hexo/source \</span><br><span class="line">*v &#123;你的博客文件夹路径&#125;/themes:/Hexo/themes \</span><br><span class="line">*v &#123;你的博客文件夹路径&#125;/_config.yml:/Hexo/_config.yml \</span><br><span class="line">xxx/hexo &#123;你的 github username&#125; &#123;你的 github email&#125; d</span><br></pre></td></tr></table></figure><p>Kitematic 中找到 hexo-deploy container，其状态应该是执行完毕。这里注意下 Docker 中的容器运行其实是执行一个程序，这里 hexo-deploy 运行完毕后即立即退出，观察效果可看自己的 GitHub pages 是否更新。</p><p>Docker 报错可看 log 中的内容，大部分问题应该是宿主机的配置问题。</p><h2 id="本章重要参考：-1"><a href="#本章重要参考：-1" class="headerlink" title="本章重要参考："></a>本章重要参考：</h2><p>1.<a href="https://wangqun.info/2016/11/29/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Docker%E8%BF%90%E8%A1%8CHexo/" target="_blank" rel="noopener">如何使用Docker运行Hexo</a></p><p>2.<a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/why.html" target="_blank" rel="noopener">Docker-从入门到实践</a></p><h1 id="四-踩坑"><a href="#四-踩坑" class="headerlink" title="四.踩坑"></a>四.踩坑</h1><p>一路顺风的搭建完？不知道看完此博客的同学们有没有这么幸运，反正我是磕磕绊绊。因此记录下我遇到的坑，以备不时之需。</p><h2 id="1-git-部署配置问题"><a href="#1-git-部署配置问题" class="headerlink" title="1.git 部署配置问题"></a>1.git 部署配置问题</h2><p>/Hexo 下 _config.yml 中 git 部署的设置一定要与以下配置雷同，空格啥的都不能差！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: XXXXXXXXXXX（git repo 的地址）</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="2-Mac-中多个-ssh-账号配置问题"><a href="#2-Mac-中多个-ssh-账号配置问题" class="headerlink" title="2.Mac 中多个 ssh 账号配置问题"></a>2.Mac 中多个 ssh 账号配置问题</h2><p>由于博主同一台电脑拥有 GitHub、Gitlab 等多个账号，同时 GitHub Pages repo 设置一个ssh类型的独立 deploy key 会更安全。因此需要修改电脑的 ssh 配置，支持多账号 ssh。</p><p>生成ssh key的具体流程不细讲，参考 <a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">GitHub ssh介绍</a> 即可。</p><h3 id="坑一："><a href="#坑一：" class="headerlink" title="坑一："></a>坑一：</h3><p>这里重点介绍 ~/.ssh/config 文件，其是配置多账号的关键。</p><p>若无 config 文件可输入以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch config</span><br></pre></td></tr></table></figure><p>创建本地 config 文件，编辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Host Test1.github.com</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_TestSSH_github</span><br><span class="line">Host Test2.gitlab.com</span><br><span class="line">HostName gitlab.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_YourProjectName_gitlab</span><br></pre></td></tr></table></figure><p>解释此配置文件：</p><p>Host： </p><blockquote><p>「 Test1.github.com 」及「 Test2.gitlab.com 」都是「别名」，可以随意命名。但之后使用到该 ssh 配置的项目其 repo 的 host 需改为与别名一致！！！上文中 _config.yml 文件配置部署 git 账号时的 repo 地址的 Host 必须与这里配置一致。</p></blockquote><p>HostName：</p><blockquote><p>该 ssh 配置的实际 host 名称，GitHub 上都为 github.com；</p></blockquote><p>User:</p><blockquote><p>用户名，设置成 git 即可，不用变</p></blockquote><p>IdentityFile：</p><blockquote><p>所使用的公钥文件;</p></blockquote><p>配置完毕，用下面的命令测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -vT git@Test1.github.com</span><br><span class="line">ssh -vT git@Test2.github.com</span><br></pre></td></tr></table></figure><h3 id="坑二："><a href="#坑二：" class="headerlink" title="坑二："></a>坑二：</h3><p>第一次修改 ssh 配置死活不成功，提示 GitHub 默认 22 端口有问题，Google 搜索让切换 443 端口，切换 443 端口后果然可以 ping 通 GitHub，但命令行执行 ssh 测试依然失败。最后回家一切正常，原来是公司的网络路由造成的影响😓。所以在公司如果配置失败的话可以回家再试试。</p><h2 id="本章重要参考：-2"><a href="#本章重要参考：-2" class="headerlink" title="本章重要参考："></a>本章重要参考：</h2><p>1.<a href="http://shinancao.github.io/2016/12/18/Programming-Git-1/" target="_blank" rel="noopener">《同一个Mac，配置多个SSH Key》</a></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>1.<a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">《搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门》</a></p><p>2.<a href="https://pages.github.com/" target="_blank" rel="noopener">《Github Pages主页》</a></p><p>3.<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">《Hexo主页》</a></p><p>4.<a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/" target="_blank" rel="noopener">《手把手教你使用Hexo + Github Pages搭建个人独立博客》</a></p><p>5.<a href="http://jeasonstudio.github.io/2016/05/26/Mac%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EGitHub-Page%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">《Mac上搭建基于GitHub Page的Hexo博客》</a></p><p>6.<a href="http://henrydong.com/2016/01/17/%E5%9F%BA%E4%BA%8ENode-js%E7%9A%84Github-Pages%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">《基于Node.js的Github Pages博客系统》</a></p><p>7.<a href="https://www.docker.com/" target="_blank" rel="noopener">《Docker官网》</a></p><p>8.<a href="https://wangqun.info/2016/11/29/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Docker%E8%BF%90%E8%A1%8CHexo/" target="_blank" rel="noopener">《如何使用Docker运行Hexo》</a></p><p>9.<a href="https://yeasy.gitbooks.io/docker_practice/content/introduction/why.html" target="_blank" rel="noopener">《Docker-从入门到实践》</a></p><p>10.<a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">github ssh介绍</a></p><p>11.<a href="http://shinancao.github.io/2016/12/18/Programming-Git-1/" target="_blank" rel="noopener">《同一个Mac，配置多个SSH Key》</a></p><p>12.<a href="http://yangfch3.com/2016/05/08/hexo-experiences/" target="_blank" rel="noopener">使用 Hexo 与 NexT 搭建博客的避坑总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了 MAC 环境下搭建独立博客的完整过程，最初的方案是 Github + Hexo，之后引入 Docker。此博客搭建方案的特点是快速、独立、免费、高自由度。本博客网站即是由此方案搭建而成，博客主题为 Next。&lt;/p&gt;
    
    </summary>
    
      <category term="博客" scheme="https://fedoryx.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="https://fedoryx.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://fedoryx.github.io/hello-world/"/>
    <id>https://fedoryx.github.io/hello-world/</id>
    <published>2017-05-16T11:11:11.000Z</published>
    <updated>2019-04-21T03:08:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hello World！ 新的故事从这里开始！ </p><a id="more"></a><h2 id="新的故事"><a href="#新的故事" class="headerlink" title="新的故事"></a>新的故事</h2><p>希望这里有满满的回忆，少年！</p><p>continue</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hello World！ 新的故事从这里开始！ &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
